\chapter{Revisão da Literatura} 
\label{capitulo:revisao}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Funções de ruído e fractais}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

As formas encontradas na natureza são geralmente complexas e ricas em detalhes. Uma cadeia montanhosa, por exemplo, apresenta variações de altitude que às vezes não pode ser representada por uma função matemática, visto que ela não possui um padrão definido (ela é completamente aleatória). Em contra-partida, certos elementos naturais apresentam um padrão bem definido, como as cores na concha de um molusco.

Para simular elementos naturais e suas peculiaridades em computação gráfica, pode-se utilizar fractais e funções de ruído. Fractais simulam elementos que possuem um padrão definido, enquanto funções de ruído adicionam a aleatoriedade existente no mundo real. Essa seção explana sobre conceitos e técnicas relacionadas a fractais e funções de ruído.

%SurveyProcedutal (fractais, pg. 3, Perlin noise pg. 6)
%-- Como utilizamos muito funções de ruido e afins, falar aqui do Perlin e do Musgrave. Falar bastante do livro deles, porque é uma coisa que é bem relacionada com o nosso trabalho e que a gente vai utilizar bastante.

%-- Só utilizamos o noise do Perlin aqui e o conceito de multi-fractal, mas sobre fractais eu vou falar depois.

\subsection{Fractais}

Um fractal é um objeto ou uma medida que apresenta auto-similaridade em qualquer escala ~\cite{SurveyProcedural}. O objeto não precisa exibir a sua estrutura exata ao longo das várias escalas, porém o mesmo "estilo" de estruturas precisa estar presente. Em um conceito puramente matemático, pode-se classificar fractais como equações que são submetidas a iterações recursivas. Como as formas geradas são auto-similares, geralmente a cada nível de recursão o padrão original é visto novamente, com algumas alterações. Fractais possuem um nível de detalhes infinito, então quanto mais iterações são realizadas, mais detalhes são criados. A figura ~\ref{fig:fractais_snowflake} ilustra o funcionamento de um fractal. É possível que fractais sejam utilizados para a geração de diversos elementos, tanto terrenos como plantas ~\cite{fractaisevery}. A utilização de fractais para a geração de relevo é uma técnica comum em computação gráfica, como pode ser visto na seção ~\ref{sec:relevo}.

\begin{figure}
\centering
\resizebox{12cm}{!}{\includegraphics{figuras/fractais_snowflake.png}}
\caption{Quatro primeiras iterações do fractal de floco-de-neve de Koch ~\cite{dollins-thesis}}
\label{fig:fractais_snowflake}
\end{figure}

Conforme já citado, fractais apresentam um padrão de auto-similaridade, o que garante uma certa homogeneidade. As formas encontradas na natureza, porém, são em sua grande maioria heterogêneas, como a forma de um montanha: quando mais próximo do cume, mais pontiagudas as formas se tornam, ao passo que na base da montanha as formas são mais suaves e planas. Aplicando o conceito de heterogeneidade à fractais obtém-se o que é denominado {\it multifractal}. Em um conceito simples, multifractais são fractais com dimensões e detalhes diferenciados ao longo de sua forma e eles são obtidos fazendo com que o seu detalhamento seja calculado em função de algum outro atributo. Considerando o exemplo da montanha já citada, o nível de suavização da forma pode ser dado em função da altitude da montanha, ou seja, quanto mais próximo do cume, menos suave as formas devem ser.

%TODO: falar aqui dos fractais do Musgrave do livro do Pozzer.

\subsection{Ruído de Perlin}
\label{sec:perlin}

O ruído de Perlin foi desenvolvido por Ken Perlin ~\cite{Perlin85}, cujo objetivo inicial era criar texturas com aparência mais natural. A função de ruído de Perlin gera um intervalo de valores que podem ser utilizados para diversos fins, dentre eles uma forma de adicionar aleatoriedade aos relevos gerados proceduralmente. Os resultados da função de ruído de Perlin são baseados no somatório dos valores de diversas funções redimensionadas, todas elas originadas de uma única função base. Essa função base é obtida a partir da interpolação de valores aleatórios gerados de forma discreta. A figura ~\ref{fig:perlin_espectro} ilustra os pontos gerados e a sua interpolação. Os pontos pertencentes ao conjunto de valores são igualmente separados entre si, compondo um "lattice" (reticulado). A interpolação entre os pontos é calculada com base num vetor gradiente pré-computado associado a cada ponto.

\begin{figure}
\centering
\resizebox{12cm}{!}{\includegraphics{figuras/perlin_espectro.png}}
\caption{À direita, valores aleatórios gerados a partir de pontos discretos. À esquerda, interpolação suave dos pontos~\cite{perlinUrl}}
\label{fig:perlin_espectro}
\end{figure}

Partindo de um conjunto de pontos discretamente coletados, um espectro de valores é criado. Em seguida, todos os pontos são interpolados entre si, criando um domínio de valores infinito. Para cada parâmetro de entrada que a função de ruído receber, um valor correspondente será encontrado na curva que foi gerada como resultado da interpolação. Para facilitar os cálculos de geração de terreno, por exemplo, pode-se condicionar a função de ruído para que os valores retornados estejam sempre contidos dentro do intervalo {\tt [-1,1]}.

Alterando-se a amplitude e a frequência da função base, obtém-se um conjunto de novas funções em outra escala. A maneira mais comum de obter novas funções em outra escala é dobrando a frequência e reduzindo a amplitude pela metade; cada nova função gerada é chamada de {\it octava}. A figura ~\ref{fig:perlin_octavas} ilustra graficamente as funções base utilizadas para a criação da função de ruído; as ilustrações de {\it (a)} até {\it (e)} são oitavas, sendo {\it (a)} a oitava de menor frequência e {\it (e)} a oitava de maior frequência. A ilustração {\it (f)} mostra o resultado da soma de todas as oitavas.

\begin{figure}
\centering
\resizebox{14cm}{!}{\includegraphics{figuras/perlin_octavas.png}}
\caption{Desenho em 2D dos pontos gerados por uma função de ruído de Perlin ~\cite{perlinUrl}}
\label{fig:perlin_octavas}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Geração de relevo}
\label{sec:relevo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%- dramatic_landscapes (dunas de areia e relevos semelhantes com heightmap)
%- mountains.gi93 (montanhas com rios)
%- p1463-ong (geração de terreno por algoritmo genéricos, não por fractais e afins)

O elemento mais básico que compõe um mundo virtual é o terreno. O terreno é a superfície que irá guiar e servir como base para todos os demais elementos que compõem o mundo, como árvores, estradas, cidades, etc. Em computação gráfica, uma das formas possíveis de se representar um terreno é através de um {\it heightmap}. Nessa abordagem, o terreno é representado por uma matriz de pontos, sendo que cada ponto {\tt (i,j)} representa a altura de um ponto do plano. Iterando-se sobre os pontos dessa matriz, conectando cada um deles através de arestas até eles formarem triângulos, é possível modelar uma malha que pode ser utilizada como um terreno virtual.

Essa seção apresenta diversas técnicas que podem ser utilizadas para a geração de um {\it heightmap} que, quando renderizado, é capaz de produzir relevos muito próximos aos que são encontrados no mundo real.


%-- Falar aqui das 3 formas que encontramos para geração de relevo através de fractais (deposição de sedimentos, alteração do ponto médio e divisão de não sei o que).

%-- Falar também sobre os multifractais que tem no livro do Musgrave, que ele usa para geração de costas de continentes muito bonitas.

\subsection{Divisões estocásticas}

Essa técnica consiste na subdivisão recursiva do {\it heightmap} através da utilização de números pseudo-aleatórios. Partindo de uma matriz com todos os pontos tendo a altura zero, o funcionamento do algoritmo é o seguinte: 

\begin{itemize}
    \item Uma altura escolhida aleatoriamente é atribuída a cada um dos cantos do retângulo. Essa altura é proporcional ao tamanho do retângulo.
	\item O retângulo é divido em quatro retângulos menores, com as alturas dos cantos de cada retângulos sendo calculada com base na interpolação das alturas dos cantos dos retângulos vizinhos ao retângulo original.
	\item O algoritmo repete os dois primeiros passos para cada retângulo gerado. A recursão é quebrada quando nível de detalhes desejado é atingido, de forma semelhante ao que ocorre na construção de um terreno utilizando-se uma quadtree.
\end{itemize}

O resultado obtido com esse algoritmo é um plano que simula as elevações montanhosas do mundo real. Embora essa abordagem seja eficiente, ela não produz resultado muito realistas, visto que a variação de altura ao longo dos pontos é linear, o que não é comum na natureza. Além disso, é possível encontrar picos ou bordas muito pontiagudos ao longo dos cantos dos quadrados gerados, o que gera um relevo irreal ~\cite{Lew87}. A figura ~\ref{fig:divisoes_estocasticas} ilustra um relevo gerado a partir de divisões estocásticas.

\begin{figure}
\centering
\resizebox{12cm}{!}{\includegraphics{figuras/divisoes_estocasticas.png}}
\caption{À esquerda, {\it heightmap} gerado a partir de divisões estocásticas; à direita, o mesmo {\it heightmap} renderizado em 3D ~\cite{dollins-thesis}}
\label{fig:divisoes_estocasticas}
\end{figure}

Existem variações desse algoritmo que visam contornar as imperfeições descritas anteriormente. Uma dessas variações é a subdivisão em forma de diamante, que consiste em rotacionar os novos quadrados gerados em 45º em relação ao quadrado original. Outra variação é afastar os quadrados novos dos cantos altos do quadrado original, recalculando as alturas dos cantos de cada um dos novos quadrados com base em pesos, o que produz um relevo mais suave e sem picos pontiagudos.


\subsection{Falhas geológicas}

A geração por falhas geológicas simula a criação de relevo por movimentação de placas tectônicas. Partindo de um terreno plano composto por uma malha regular, o algoritmo escolhe aleatoriamente uma linha que divide o terreno em duas partes. Para um dos lados, a altura dos pontos é incrementada em uma certa quantidade, enquanto a altura dos pontos do outro lado é decrementada dessa mesma quantidade. Depois disso, o valor usado para aumentar/diminuir as alturas é reduzido em uma certa quantidade e o algoritmo é repetido. No momento que esse valor chegar a zero o algoritmo termina.

O relevo gerado com esse método não apresenta elevações pontiagudas como no algoritmo de subdivisões estocásticas, porém ele é muito lento para ser utilizado numa abordagem de tempo real. Depois que a linha divisória é escolhida, todos os pontos da matriz precisam ser atualizados e isso é feito a cada iteração do algoritmo. A figura ~\ref{fig:falhas_geograficas} ilustra um relevo gerado a partir de falhas geológicas.

\begin{figure}
\centering
\resizebox{12cm}{!}{\includegraphics{figuras/falhas_geograficas.png}}
\caption{À esquerda, {\it heightmap} gerado a partir de falhas geológicas; à direita, o mesmo {\it heightmap} renderizado em 3D ~\cite{CS4802}}
\label{fig:falhas_geograficas}
\end{figure}


\subsection{Deposição de sedimentos}

A geração por deposição de sedimentos simula a criação de relevo por fluxos de lava. Nessa abordagem, pontos de liberação de sedimentos são escolhidos e, em cada um desses pontos, um determinado número de sedimentos é depositado. Cada partícula depositada irá tentar chegar até o ponto mais baixo da região onde foi depositada, escorregando por cima das demais partículas. Se a partícula cair em um local no qual todas as posições à sua volta tem a mesma altura, então ela termina o movimento.

Variando-se os pontos de deposição de partículas e a quantidade de elementos depositados em cada ponto, é possível gerar terrenos visualmente aceitáveis. Novamente o tempo de execução do algoritmo é um problema; para cada partícula depositada faz-se necessário o calculo de movimentação desse elemento, o que, dependendo do número de iterações, pode ter um custo computacional grande. Além disso, o algoritmo apresenta uma complexidade de implementação maior que os demais já citados. A figura ~\ref{fig:heightmap_deposicao} ilustra alguns {\it heightmaps} obtidos com o algoritmo de deposição de sedimentos.

\begin{figure}
\centering
\resizebox{14cm}{!}{\includegraphics{figuras/heightmap_deposicao.png}}
\caption{{\it Heightmaps} obtidos com o algoritmo de deposição de sedimentos. ~\cite{CS4802}}
\label{fig:heightmap_deposicao}
\end{figure}


\subsection{Disposição do ponto médio}

Essa técnica consiste em perturbar o ponto médio de um determinado segmento. Em uma abordagem 2D, por exemplo, dado um determinado segmento, o algoritmo acha o ponto médio desse segmento e, utilizando um número pseudo-aleatório, aumenta ou diminui a altura desse ponto em uma determinada quantidade. Em seguida, essa quantidade utilizada para perturbação é reduzida e o algoritmo é aplicado novamente aos dois novos segmentos gerados a partir da perturbação do ponto médio. A figura ~\ref{fig:midpoint} ilustra o funcionamento do algoritmo.

\begin{figure}
\centering
\resizebox{8cm}{!}{\includegraphics{figuras/midpoint.png}}
\caption{Geração de relevo pela disposição do ponto médio (perspectiva 2D) ~\cite{dollins-thesis}}
\label{fig:midpoint}
\end{figure}


\subsection{Ruído de Perlin}
\label{sec:ruidoperlin}

Essa técnica consiste em utilizar funções de ruído de Perlin para causar perturbações no {\it heightmap}. A utilização de uma função de ruído de Perlin num {\it heightmap} não produz, por si só, um relevo visualmente parecido com aqueles encontrados na natureza; a combinação de diversas camadas de ruido, porém, é capaz de produzir um efeito mais natural e convincente. Cada uma dessas recursões, chamadas de octavas, possui uma amplitude e uma frequência, e a combinação delas é comumente chamada de turbulência de Perlin. A figura ~\ref{fig:perlin_heightmap} ilustra os resultados obtidos com essa técnica.

\begin{figure}
\centering
\resizebox{8cm}{!}{\includegraphics{figuras/perlin_heightmap.png}}
\caption{À direita, {\it heightmap} gerado a partir de ruído de Perlin com alta frequência. À esquerda, {\it heightmap} gerado com ruídos de menor frequência. ~\cite{LandscapeGeneration}}
\label{fig:perlin_heightmap}
\end{figure}

As características do relevo podem ser ajustadas através da modificação do número de octavas e da frequência de cada uma delas. Quanto maior for a frequência da octava adicionada, maior será a quantidade de detalhes do relevo. Uma variação para a geração de relevo através de ruído de Perlin é a técnica conhecida como ruido de Perlin {\it ridged}, que consiste na utilização de funções com valores absolutos em conjunto com a função de ruído original para produzir um relevo com mais "cristas". Na abordagem original, no intervalo {\tt [-1,1]}, que é o domínio da função de ruído, {\tt -1} indicaria um local muito baixo no mapa, ao passo que {\tt 1} indicaria o cume da montanha mais alta; na versão {\it ridged}, o algoritmo original é modificado para que os valores {\tt -1} e {\tt 1} gerem relevos de baixa altitude, ao passo que os valores gerados ao longo do intervalo {\tt [-1,1]} são de grande altitude. A figura ~\ref{fig:perlin_ridged} ilustra os resultados obtidos com essa abordagem.

\begin{figure}
\centering
\resizebox{12cm}{!}{\includegraphics{figuras/perlin_ridged.png}}
\caption{À esquerda, {\it heightmap} gerado a partir da técnica de ruído de Perlin {\it ridged}; à direita, o mesmo {\it heightmap} renderizado em 3D ~\cite{LandscapeGeneration}}
\label{fig:perlin_ridged}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mundos pseudo-infinitos}
\label{sec:mundos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%-- falar aqui das zilhoes de abordagens para geração de mundos infinitos que nós encontramos. Parece que todo mundo resolveu fazer pesquisa sobre isso de uma hora para outra.

%- p87-greuter (geração de cidades virtuais);
%- LandscapeGeneration (geração de mundos, ruido do Perlin, fractais para relevo, texturizacao, geração de plantas, cidades, nuvens)
%- LindaOndrej2007 (ferramenta para geração de mundo circular, VARIOS ruidos do Perlin, fractais e multifractais, colorização)
%- terrain_generation (geração de terrenos finitos aplicados a um jogo caso de uso)
%- dollins-thesis (geração procedimental de mundos virtuais muito grandes usando quad-trees e divisões estocásticas)

%Ferramentas:

%-- http://landscapestudio.omgames.co.uk/screenshots.html
%-- http://www.vterrain.org/
%-- http://www.pandromeda.com/products/mojoworldpro.php
%-- http://wwwcg.in.tum.de/Research/Publications/FractalTerrain
%-- http://www.howardzzh.com/research/terrain/
%-- http://www.cs.brown.edu/~scd/world/home.html (exatamente o que queremos fazer)
%-- http://www.earth3d.org/
%-- http://www.planetside.co.uk/terragen/

\subsection{Cidade virtual}

A geração de conteúdos procedimentais é um assunto antigo no campo da computação gráfica. A aplicação desse tipo de técnica na geração de um mundo virtual completo foi utilizada por ~\citet{infinicity}, cujo objetivo era gerar uma cidade virtual que fosse visualmente interessante e composta por construções complexas, porém cada uma delas sendo criada a partir de elementos mais simples.

Na abordagem utilizada, dividiu-se o mundo virtual numa grade composta por diversos quadrados, chamados células. As coordenadas de localização de cada célula, em conjunto com uma semente global, são utilizadas como entrada para uma função de hash ~\cite{wangHash}. O resultado dessa função é utilizado como semente para um pseudo gerador de números aleatórios e irá definir todas as características das construções que estão dentro da célula. Dessa forma, o conteúdo de uma célula é sempre o mesmo, independente de quanto o usuário caminhe pelo mundo virtual e faça a célula em questão entrar ou sair do seu campo de visão. A figura ~\ref{fig:greuter_grade} ilustra a divisão do mundo virtual em células.

\begin{figure}
\centering
\resizebox{15cm}{!}{\includegraphics{figuras/greuter_grade.png}}
\caption{Mundo virtual dividido em células. Cada uma delas possui uma semente calculada com base em sua posição e com base uma semente global referente à cidade ~\cite{infinicity}}
\label{fig:greuter_grade}
\end{figure}

Cada uma das construções existentes é gerada pela mescla de polígonos simples escolhidos aleatoriamente. Utilizando um processo iterativo, partindo do topo até a base, em cada iteração o polígono escolhido é mesclado com o polígono anterior e, então, mais um nível (andar) é criado; esse processo garante que a construção, ao longo das iterações, cresça em altura e em largura de uma forma realista. Depois que a geometria da construção está pronta, ela é texturizada com janelas, sendo que o tipo da janela é escolhido aleatoriamente. A figura ~\ref{fig:greuter_predios} ilustra a geração de construções.

\begin{figure}
\centering
\resizebox{15cm}{!}{\includegraphics{figuras/greuter_predios.png}}
\caption{Geração de construções: cada andar é gerado pela mescla de polígonos escolhidos e centralizados aleatoriamente ~\cite{infinicity}}
\label{fig:greuter_predios}
\end{figure}

Para garantir o uso racional de recursos computacionais, como memória e processamento, utilizou-se o conceito nomeado por eles de preenchimento por {\it view frustum}, que consiste em restringir à geração de conteúdo somente para as células que estão dentro do campo de visão do usuário. A medida que este anda pela cidade virtual, novas células vão sendo adicionadas ao campo de visão, sendo o seu conteúdo gerado de acordo com necessidade; quando a célula sai do campo de visão, ela é removida da memória e seus recursos são liberados. As células são posicionadas em loops quadrados ao redor do usuário e são consideradas pertencentes ao campo de visão se estão a uma certa distância do usuário e dentro de um ângulo de 120º de visão. A figura ~\ref{fig:greuter_view} ilustra o funcionamento do campo de visão descrito e a figura ~\ref{fig:greuter_cidade} mostra uma cidade virtual gerada.

\begin{figure}
\centering
\resizebox{5cm}{!}{\includegraphics{figuras/greuter_view.png}}
\caption{Campo de visão do usuário: apenas as células visíveis tem o seu conteúdo gerado ~\cite{infinicity}}
\label{fig:greuter_view}
\end{figure}

\begin{figure}
\centering
\resizebox{15cm}{!}{\includegraphics{figuras/greuter_cidade.png}}
\caption{Exemplo de cidade virtual gerada ~\cite{infinicity}}
\label{fig:greuter_cidade}
\end{figure}

\subsection{Geração e texturização por camadas}

Outro trabalho analisado foi o de ~\citet{LandscapeGeneration} para a construção da ferramenta SkyCastle ~\cite{SkyCastle}, uma {\it engine} para jogos online multijogador com suporte à geração procedimental de mundos virtuais. No referido trabalho, há um enfoque no problema de mundos virtuais cada vez maiores em jogos de computador e aplicações, o que gera a necessidade de desenvolvimento de ferramentas capazes de ajudar na geração de conteúdos realistas para esses mundos. Para a geração de relevo, utiliza-se procedimentos parametrizados e sistemas baseados em fractais em uma abordagem de camadas: a aplicação adiciona um mapa de ruído (com amplitude reduzida) ao mapa de altura base em cada iteração. Os mapas de ruído são pré-computados e criados através de funções de ruído de Perlin, abordagem semelhante ao método de geração de relevo por deposição de sedimentos, que foi abordado em mais detalhes na seção ~\ref{sec:relevo}.

Para a texturização da malha gerada, um dos métodos apresentados é a utilização de uma imagem com proporções muito grandes, que seria capaz de cobrir o mundo inteiro. Embora essa abordagem possa ser útil para cenários pequenos, ela não é viável para terrenos grandes ou mundos virtuais, uma vez que o tamanho da imagem poderia atingir proporções proibitivas. Para contornar esse problema, a abordagem de reticulados é sugerida~\cite{CSHD03}; nessa abordagem, uma célula de textura é criada de tal forma que ao posicionar várias células, uma do lado da outra, o plano gerado apresenta uma texturização contínua. O resultado obtido com essa abordagem é aceitável, porém ele não é visualmente atraente para o usuário final, uma vez que o terreno apresenta uma continuidade que não existiria no mundo real. Para conseguir um resultado visual melhor, sugere-se a utilização de uma abordagem proposta por ~\citet{LN03}, que consiste na utilização de um conjunto de texturas pré-definidas juntamente com a texturização em reticulados já citada. O funcionamento do algoritmo resume-se em aplicar as texturas pré-definidas sobre um plano já uniformemente texturizado, porém utilizando transparência nas áreas não desenháveis das texturas pré-definidas. As áreas não desenháveis são calculadas com base em alguma característica do terreno, como a altura de cada ponto. Dessa forma, a sobreposição das texturas pré-definidas sobre o plano texturizado irá produzir uma paisagem menos homogênea, o que gera um resultado visual melhor. A figura ~\ref{fig:tiling} ilustra as texturas pré-definidas e a sua utilização na abordagem descrita.

\begin{figure}
\centering
\resizebox{15cm}{!}{\includegraphics{figuras/tiling.png}}
\caption{Terreno texturizado com duas camadas: bloco escuro e um conjunto de texturas em formato de borda com transparência ~\cite{LandscapeGeneration}}
\label{fig:tiling}
\end{figure}

Para ornamentar o mundo virtual, cita-se a utilização de plantas proceduralmente geradas através de três métodos principais: {\it L-System}~\cite{PL90}, geração baseada em componentes ~\cite{LD98} e árvores parametrizadas ~\cite{WP95}. O algoritmo {\it L-System} consiste na geração de elementos a partir da interpretação de uma cadeia de caracteres, sendo que cada um desses caracteres representa uma estrutura geométrica ou operação (rotação, translação, etc); a cadeia de caracteres resultante é obtida a partir da aplicação sucessiva de regras sobre uma cadeia base. O algoritmo de geração baseado em componentes consiste na interpretação de uma árvore de elementos, sendo cada um desses elementos modificável através de parâmetros; cada componente pode possuir filhos e, também, uma descrição de qual é o elemento que pode ser usado como folha da árvore. Por fim, a geração de árvores parametrizadas é conceitualmente semelhantes à geração por componentes, exceto que a geração é orientada a ramificações; cada ramificação da árvore corresponde à um nível de recursão, sendo o tronco da árvore o nível zero; quando um ramo sofre uma divisão, os filhos resultantes dessa divisão herdam algumas características do pai (como resolução), porém eles adquirem características próprias, como o ângulo de curvatura; ao final do processo, através de um estudo dos parâmetros corretos a serem utilizados (como a quantidade de ramos, o nível de recursão, etc), é possível que uma árvore completa seja gerada.

\subsection{Planetas procedurais}

Uma das abordagens analisadas trata da geração de planetas procedurais através de fractais combinados com outros métodos ~\cite{LindaOndrej2007}. Nessa abordagem, o mundo gerado não é infinito, porém é esférico e simula a visualização do planeta Terra. Partindo da subdivisão recursiva de um octaedro, cria-se um mundo esférico que serve como base para a aplicação dos algoritmos de relevo. Utiliza-se o conceito de LOD ({\it level of detail} ~\cite{lod}) para garantir um bom desempenho da aplicação.

\begin{figure}
\centering
\resizebox{15cm}{!}{\includegraphics{figuras/mundo_esferico_relevo.png}}
\caption{Diferentes relevos gerados pela utilização de fractais e suas combinações.~\cite{LindaOndrej2007}}
\label{fig:mundo_esferico_relevo}
\end{figure}

O relevo gerado é obtido através de diversas técnicas, cada uma com suas peculiaridades e resultados. Dentre as técnicas estudadas, utilizou-se: geração por falhas aleatórias, disposição do ponto médio (incluindo uma variação multifractal) e ruido de Perlin (e suas diversas variações). A figura ~\ref{fig:mundo_esferico_relevo} ilustra os relevos obtidos com essas técnicas. Depois que a malha é gerada, utiliza-se uma combinação de técnicas para colorir os pontos da falha; as técnicas variam conforme o resultado desejado, porém todas elas são baseadas na interpolação de cores parametrizadas pela altura do ponto sendo analisado. Para garantir um aspecto mais real, utiliza-se um fator de aleatoriedade através de ruídos e turbulências.

Tento em vista os diversos métodos para geração de relevo explorados, é importante salientar quais foram os resultados obtidos com a utilização de cada um deles frente ao problema de geração de continentes para um mundo esférico. Uma visão mostrando todos os planetas gerados é mostrada na figura ~\ref{fig:mundos_esfericos}. O algoritmo de geração por {\bf falhas aleatórias} produz terrenos que parecem quebrados e diversas ilhas pequenas; de acordo com a análise feita, os resultados obtidos em sua grande maioria são muito aleatórios e na média o algoritmo produz um grande continente e um grande oceano. O algoritmo de {\bf disposição do ponto médio} e sua variação multifractal geram continentes grandes e compactos sem muitas ilhas pequenas, com as deformações geradas sendo uniformes e concentradas no centro dos continentes; embora a variação multifractal do algoritmo produza uma colorização aceitável (tento em vista que há grandes variações de altitude), segundo a análise os resultados não são bons quanto os obtidos com ruído de Perlin. O algoritmo de {\bf ruído de Perlin} e sua variação multifractal apresentam resultados visuais melhores em comparação com as técnicas citadas anteriormente; a comparação entre o planeta gerado apenas com ruído de Perlin e o planeta gerado pela sua variação multifractal mostra a considerável diferença existente entre essas duas abordagens: enquanto a primeira produz relevos com variações de altitude concentradas em determinados lugares, a segunda produz relevos mais realistas com uma distribuição menos concentrada em determinados pontos. Por último, as variações {\it ridged} da geração por {\bf ruído de Perlin} produzem planetas com continentes estreitos e arredondados, algumas vezes gerando baías fechadas; da mesma forma que os resultados anteriores mostraram, uma abordagem multifractal gera um relevo com variações de altitude mais distribuídas ao longo dos continentes.

\begin{figure}
\centering
\resizebox{15cm}{!}{\includegraphics{figuras/mundos_esfericos.png}}
\caption{Planetas gerados com os diversos algoritmos. (a) Falhas aleatórias. (b) Disposição do ponto médio. (c) Disposição do ponto médio multifractal. (d) Ruído de Perlin. (e) Ruído de Perlin Multifractal. (f) Ruído de Perlin {\it Ridged}. (g) Ruído de Perlin {\it Ridged} Multifractal.~\cite{LindaOndrej2007}}
\label{fig:mundos_esfericos}
\end{figure}

\subsection{Fractais refinados por erosão}

Outro trabalho analisado foi a geração de terrenos procedimentais em tempo real com a utilização de fractais refinados por erosão ~\cite{terrain_generation}. Conforme ressaltado, o aumento do poder de processamento de computadores domésticos possibilitou que jogos de computador façam uso de simulações de erosão em tempo quase real. Agregou-se à geração de relevo por fractais novas características decorrentes da aplicação de erosão, o que teve como resultado mapas mais reais e, ao mesmo tempo, customizáveis. Primeiramente, um mapa de altura foi criado a partir de um diagrama de Voronoi, sendo cada um dos vértices do diagrama chamados de {\it pontos de funcionalidade}; o valor de cada célula no mapa de altura é obtido através de uma combinação linear das distâncias entre os pontos de funcionalidade mais próximos. Depois que o mapa de altura é gerado, ele é combinado com um algoritmo de geração de ruído para produzir montanhas menos pontiagudas. Para remover as linhas bem definidas criadas pelo diagrama de Voronoi, um filtro de perturbação é aplicado. A figura ~\ref{fig:erosao_evolucao} ilustra o processo descrito. 

\begin{figure}
\centering
\resizebox{15cm}{!}{\includegraphics{figuras/erosao_evolucao.png}}
\caption{(a) Mapa de altura gerado a partir de um diagrama de Voronoi. (b) Aplicações de funções de ruído em (a). (c) Mapa resultante da aplicação de um filtro de perturbação em (b).~\cite{terrain_generation}}
\label{fig:erosao_evolucao}
\end{figure}

Para a simulação de erosão no mapa de altura gerado, utiliza-se um método híbrido de duas técnicas de erosão: a termal e a hidráulica. A erosão termal consiste na simulação de sedimentos se desprendendo de áreas mais altas e deslizando para baixo, na base do relevo. Aplicando uma série de otimizações sobre o algoritmo original proposto por ~\citet{MusgraveErosao}, obtiveram-se resultados satisfatórios que podem ser utilizados em uma abordagem em tempo real para jogos. A erosão hidráulica simula a deposição de sedimentos causada pelo transporte de materiais dissolvidos num fluxo de água corrente. Em uma comparação entre os dois métodos, a erosão hidráulica apresentou melhores resultados visuais, porém mesmo a sua implementação otimizada não foi mais rápida que a erosão termal otimizada. Criou-se, então, uma mescla entre as duas técnicas, alterando o método de erosão hidráulica para que o resultado ficasse mais próximo ao método de erosão termal. O resultado obtido é uma técnica capaz de gerar resultados visuais tão bons quanto o método da erosão hidráulica, porém com o desempenho do método de erosão termal, o que permite que a técnica seja utiliza em tempo real em jogos. A figura ~\ref{fig:erosao_ilustracao} ilustra o resultado final obtido.

\begin{figure}
\centering
\resizebox{15cm}{!}{\includegraphics{figuras/erosao_ilustracao.png}}
\caption{À direita, renderização de um mapa de altura sem a aplicação de erosão; à esquerda, o mesmo mapa com a aplicação de erosão. ~\cite{terrain_generation}}
\label{fig:erosao_ilustracao}
\end{figure}

\subsection{Divisões estocásticas de uma {\it quadtree}}

Outro trabalho analisado foi a geração procedimental de mundos virtuais através de técnicas de subdivisão estocásticas ~\cite{dollins-thesis}. O objetivo foi criar um mundo virtual de grandes proporções, porém gerando o seu conteúdo sob-demanda de forma procedimental e com multi-resolução. Para a geração do relevo do terreno, utilizou-se sub-divisões de uma {\it quadtree} em um processo recursivo, como ilustra a figura ~\ref{fig:dollin_quadtree}. A forma do terreno é definida pelo ponto médio de cada uma das células, que na figura são representados pelos círculos pequenos no centro de cada quadrado. Para cada nível de subdivisão, os novos pontos médios das células filho criadas são definidos em função das nove células pai que estão ao redor da célula sendo dividida. A altura dos demais pontos da malha, como os vértices que estão nos cantos das células, é definida pela interpolação dos pontos médios mais próximos. A cada camada de detalhamento, mais células são subdivididas, e a célula que sofreu a subdivisão é substituída pelas novas células filho geradas. Na figura ~\ref{fig:dollin_quadtree}, o quadrado localizado no centro representa uma célula que está sofrendo subdivisões e que será substituída pelas quatro células filho resultantes da subdivisão (as células filhos são os quadrados com círculos brancos no centro). Tendo em vista que as subdivisões são baseadas em cálculos estocásticos, necessitou-se de uma forma de geração de números aleatórios que pudesse prover uma sequência confiável de números ao longo de todo o processo de subdivisão, visto que são vários níveis de detalhes, cada um deles gerando várias células com diversos pontos. Para evitar repetições de números ao longo dos vários níveis de detalhamento, utilizou-se um gerador de números aleatórios alimentado por três elementos: as coordenadas {\tt X} e {\tt Y} da célula e o nível de detalhe sendo mostrado nesse momento; isso garante que um conjunto de números aleatórios seja gerado de forma satisfatória para cada um das células existentes no mundo virtual, independente do nível de detalhes exigido.


\begin{figure}
\centering
\resizebox{8cm}{!}{\includegraphics{figuras/dollin_quadtree.png}}
\caption{{\it Quadtree} utilizada para a geração do terreno ~\cite{dollins-thesis}}
\label{fig:dollin_quadtree}
\end{figure}

Para controlar a instanciação de cada célula, conforme a câmera se movimenta, novas células são instanciadas à frente da câmera e as células atrás da câmera, que estão muito distantes, são removidas da memória. Os nós pai sempre instanciam todos os seus filhos e os nós que estão dentro de um determinada camada (nível da árvore) só serão atualizados quando a câmera atingir o ponto médio da célula pai. À medida que a câmera se move para a direita, por exemplo, ultrapassando o ponto médio das células pai, novos nós vão sendo instanciados à direita (à medida que o nó pai entra no campo de visão), ao passo que todos os nós pai que saem do campo de visão são removidos (junto com os seus filhos). A malha final é renderizada a partir das informações conditas nas folhas da árvore, sendo que a altura de cada um desses pontos na malha é definido pela interpolação de seu ponto médio com a vizinhança, como descrito anteriormente.

Para garantir o desempenho no cálculo dos pontos médios da vizinhança, buscou-se uma forma de pesquisar, com um tempo constante, os nós vizinhos duma determinada célula. Para encontrar os vizinhos imediatos a uma célula, basta que a relação de pai e filho da árvore seja utilizada, o que irá resultar em uma busca de apenas dois ponteiros (um do nó atual até o pai dele e outro do pai até o nó irmão). O problema está no cálculo para encontrar as células vizinhas mais distantes, que podem estar a uma distância arbitrária do nó atual, ou seja, vários ponteiros deverão ser consultados até que os vizinhos desejados sejam encontrados. Uma das soluções encontradas para essa busca é a utilização de uma tabela hash para indexar todos os nós de uma determinada camada (nível da árvore). Utilizando essa abordagem, o tempo de busca de qualquer nó de uma camada se tornaria constante. Outra solução encontrada é utilizar um vetor bi-dimensional para indexar os nós de uma determinada camada. Conforme apontado, quando uma camada deve ser atualizada (porque o ponto médio de uma célula pai foi atingido), a melhor abordagem é a utilização de um vetor; mesmo que o custo para atualizar todos os nós de um vetor seja mais alto do que apenas inserir uma nova entrada na tabela hash, a busca em vetor é mais rápida do que o processo de calcular a chave de hash de cada célula a partir de suas coordenadas.

%\begin{figure}
%\centering
%\resizebox{8cm}{!}{\includegraphics{figuras/dollin_bintree.png}}
%\caption{Subdivisão de células e níveis de detalhe representados por uma árvore binária em 2D. ~\cite{dollins-thesis}}
%\label{fig:dollin_bintree}
%\end{figure}


\subsection{Gerador de mapas para planetas}
\label{sec:geradortorben}

Outro trabalho analisado foi um gerador de mapas para planetas, que consiste na geração de mundos esféricos através da subdivisão recursiva de um tetraedro ~\cite{torben}. Embora o trabalho não seja apresentado como uma ferramenta gráfica na qual o usuário pode explorar um ambiente 3D, todas as informações geradas são parte de um mundo virtual completo, com continentes e oceanos altamente customizáveis. A ideia apresenta a criação de um mapa como resultado da projeção de pixels numa esfera. Cada pixel do mapa a ser gerado é projetado para uma esfera, sendo que o algoritmo que faz a projeção atribui uma altura ao pixel encontrado, o que gera um mapa com relevo.

Para renderizar um mapa, inicialmente encontram-se os pontos dele que são visíveis na superfície da esfera. Em seguida, para calcular a altura de cada um desses pontos, aplica-se o seguinte algoritmo:

\begin{itemize}
 \item Inserir a esfera dentro do tetraedro.
 \item Cortar o tetraedro em dois tetraedros menores.
 \item Escolher em qual dos dois tetraedros está localizado o ponto sendo analisado.
 \item Repetir os passos anteriores até que o tetraedro seja pequeno o suficiente
 \item Usar a altura média dos vértices do tetraedro para calcular a altura do ponto sendo procurado.
\end{itemize}

No algoritmo de projeção analisado faz-se uso de um tetraedro para encontrar o ponto correspondente na superfície da esfera. A figura ~\ref{fig:explicacao_torben_tetraedro} ilustra o tetraedro inicial utilizado no processo.

\begin{figure}
\centering
\resizebox{3cm}{!}{\includegraphics{figuras/explicacao_torben_tetraedro.png}}
\caption{Tetraedro inicial utilizado no processo de projeção. ~\cite{torben}}
\label{fig:explicacao_torben_tetraedro}
\end{figure}

Inicialmente a esfera é colocada dentro de um tetraedro irregular e informações sobre altura e uma semente para cálculos aleatórios é colocada em cada um dos vértices dele. Em seguida, ele é dividido em dois pelo plano formado entre o ponto médio da aresta mais longa e os dois pontos finais da aresta oposta ao ponto médio. Em suma, cada um dos dois tetraedros resultantes terão três vértices a partir do tetraedro original mais um novo vértice posicionado no ponto médio da maior aresta. A altura e a semente do novo vértice são calculados a partir da altitude e semente dos pontos finais da linha que é dividida (maior aresta). O processo é repetido recursivamente para cada um dos tetraedros até que ele fique pequeno o suficiente para conter apenas o ponto desejado. A figura ~\ref{fig:explicacao_torben_resultado} ilustra alguns mapas obtidos com diferentes tipos de projeção.

\begin{figure}
\centering
\resizebox{12cm}{!}{\includegraphics{figuras/explicacao_torben_resultado.png}}
\caption{Mapas obtidos com a aplicação do algoritmo de subdivisão do tetraedro. ~\cite{torben}}
\label{fig:explicacao_torben_resultado}
\end{figure}

Pode-se utilizar diferentes tipos de projeção para coleta dos pontos da esfera. Além disso, é possível aplicar zoom ao mapa sendo gerado, bastando para isso aumentar o número de passos necessários para o cálculo de cada pixel. A figura ~\ref{fig:explicacao_torben_zoom} mostra dois mapas com a aplicação de zoom.

\begin{figure}
\centering
\resizebox{12cm}{!}{\includegraphics{figuras/explicacao_torben_zoom.png}}
\caption{Zoom realizado sobre diferentes mapas. ~\cite{torben}}
\label{fig:explicacao_torben_zoom}
\end{figure}

O mapa gerado apresenta continuidade ao longo dos continentes, uma vez que foi originado de uma esfera. Isso quer dizer que se o usuário seguir o trajeto de algum meridiano, ele irá retornar para o exato ponto de partida sem qualquer tipo de quebra de conteúdo ao longo do processo.